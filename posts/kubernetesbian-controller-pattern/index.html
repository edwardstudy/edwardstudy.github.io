<!doctype html><html lang=en><meta charset=utf-8>
<meta name=viewport content="width=device-width">
<title>Kubernetes编程范式——Controller pattern | Edwardesire</title>
<meta name=generator content="Hugo Eureka 0.8.3">
<link rel=stylesheet href=/css/eureka.min.css>
<script defer src=/js/eureka.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload="this.onload=null,this.rel='stylesheet'">
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity="sha256-Zmpaaj+GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE=" crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_3.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_3.png>
<meta name=description content="引子 Kubernetes的定位是非常明确和简单的，就是容器的编排与调度管理的系统。Kubernetes所关注的核心就是容器（Container）。Ku">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/posts/"},{"@type":"ListItem","position":2,"name":"Kubernetes编程范式——Controller pattern","item":"/posts/kubernetesbian-controller-pattern/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/kubernetesbian-controller-pattern/"},"headline":"Kubernetes编程范式——Controller pattern | Edwardesire","datePublished":"2019-05-14T06:50:13+00:00","dateModified":"2019-05-14T06:50:13+00:00","wordCount":3773,"publisher":{"@type":"Person","name":"C. Wang","logo":{"@type":"ImageObject","url":"/images/icon.png"}},"description":"引子 Kubernetes的定位是非常明确和简单的，就是容器的编排与调度管理的系统。Kubernetes所关注的核心就是容器（Container）。Ku"}</script><meta property="og:title" content="Kubernetes编程范式——Controller pattern | Edwardesire">
<meta property="og:type" content="article">
<meta property="og:image" content="/images/icon.png">
<meta property="og:url" content="/posts/kubernetesbian-controller-pattern/">
<meta property="og:description" content="引子 Kubernetes的定位是非常明确和简单的，就是容器的编排与调度管理的系统。Kubernetes所关注的核心就是容器（Container）。Ku">
<meta property="og:locale" content="en">
<meta property="og:site_name" content="Edwardesire">
<meta property="article:published_time" content="2019-05-14T06:50:13+00:00">
<meta property="article:modified_time" content="2019-05-14T06:50:13+00:00">
<meta property="article:section" content="posts">
<meta property="article:tag" content="Kubernetes">
<meta property="article:tag" content="Operator">
<meta property="og:see_also" content="/posts/intro-operator/">
<meta property="og:see_also" content="/posts/deploy-kubernetes-by-kubeadm/">
<body class="flex flex-col min-h-screen">
<header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
<div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName('html')[0].classList.add('dark')</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
<a href=/ class="mr-6 text-primary-text text-xl font-bold">Edwardesire</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i>
</button>
<div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
<div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
<a href=/posts/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item mr-4">Posts</a>
</div>
<div class=flex>
<div class="relative pt-4 md:pt-0">
<div class="cursor-pointer hover:text-eureka" id=lightDarkMode>
<i class="fas fa-adjust"></i>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open>
</div>
<div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions>
<span class="px-4 py-1 hover:text-eureka" name=Light>Light</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>Dark</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>Auto</span>
</div>
</div>
</div>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile>
</div>
</nav>
<script>let element=document.getElementById('lightDarkMode');storageColorScheme==null||storageColorScheme=='Auto'?document.addEventListener('DOMContentLoaded',()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change',switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'sun'),element.firstElementChild.classList.add('fa-sun')):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'moon'),element.firstElementChild.classList.add('fa-moon')),document.addEventListener('DOMContentLoaded',()=>{getcolorscheme(),switchBurger()})</script>
</div>
</header>
<main class="flex-grow pt-16">
<div class=pl-scrollbar>
<div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">
<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
<div class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
<h1 class="font-bold text-3xl text-primary-text">Kubernetes编程范式——Controller pattern</h1>
<div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
<div class="mr-6 my-2">
<i class="fas fa-calendar mr-1"></i>
<span>2019-05-14</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-clock mr-1"></i>
<span>8 min read</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-folder mr-1"></i>
<a href=/categories/kubernetes/ class=hover:text-eureka>Kubernetes</a>
<span>, </span>
<a href=/categories/operator/ class=hover:text-eureka>Operator</a>
</div>
</div>
<div class=content>
<h1 id=引子>引子</h1>
<p>Kubernetes的定位是非常明确和简单的，就是容器的编排与调度管理的系统。Kubernetes所关注的核心就是容器（Container）。Kubernetes提出的一个很重要的理念就是：不应该只管理单个容器，而应该管理容器组(Pod)。通过对Pod功能的扩展，可以进一步定义不同的对象。比如拥有多个Pod副本的Deployment，提供访问Pod功能的Service和只执行一次的Job等。</p>
<p>Kubernetes它工作的整个核心就是围绕这些存储在Etcd里的对象来工作的，这就是我们称之为Reconcile。前面所提到的Pod就是最小的API对象。</p>
<h1 id=1--api对象>1. API对象</h1>
<p>Kubernetes使用API对象来表示容器化的应用状态。一旦创建了一个API对象，Kubernetes会持续地工作保证该对象的当前状态和所需状态一致。通过Kubernetes API可以自由地操作对象的状态，这套机制支持在资源路径通过HTTP方法（methods）来创建，更新，删除和获取资源实例。</p>
<p>Kubernetes定义了下列几个术语来描述API对象。</p>
<ul>
<li>Kind：对象的类型，每一个对象都有Kind字段来记录它的类型。比如常用的<code>Job</code>类型。</li>
<li>API Group：逻辑上相关的Kinds集合。比如Job和CronJob都在<code>batch Group</code>里。</li>
<li>Version：每个API Group可以存在多个版本。比如<code>v1alpha1</code>，<code>v1beta1</code>等等。</li>
<li>Resource：代表Kubernetes的对象实体，比如<code>.../namespaces/default</code>。</li>
</ul>
<p>一个API对象在Etcd里的完整资源路径，是由上述的Group、Version和Resource三个部分组成的。</p>
<p>这里以Job举例：</p>
<pre><code class=language-yaml>apiVersion: batch/v1
kind: Job
metadata:
  name: post-deployment-job
...
</code></pre>
<p>在这个YAML文件中，Job就是这个API对象的资源类型（Kind），<code>batch</code>就是它的组（Group），v2alpha1 就是它的版本（Version）。通过这样的结果就能够在整个Kubernetes的所有API对象中找到资源。</p>
<p><img src=http://edwardsblog.edwardesire.com/image/2019/05/FsDycgUbLZKBRLu_h7nGkbJBZvsF.png alt></p>
<p>首先是匹配对象的组<code>Batch</code>，然后找到API对象的版本<code>v1</code>，最后匹配API的资源类型<code>Job</code>。更准确的说，<code>Job</code>的实际路径是<code>/apis/batch/v1/namespaces/$NAMESPACE/jobs</code>。因为<code>Job</code>不是cluster范围的资源，所以它需要指定具体的namespace。</p>
<p>回到我们的题目上来，Kubernetes面向API Object的编程模型有两个操作：</p>
<ol>
<li>通过API在Etcd里面创建一个对象</li>
<li>通过控制循环（Control Loop）的来调协（Reconcile）所创建对象的状态</li>
</ol>
<p>Kubernetes里面的所有组件，Scheduller，Kubelet等等，他们都维护了自己的一个Control Loop，相当于在不断地循环监控变化并进行调协。</p>
<p>什么叫做调协（Reconcile）？比如说我现在创建一个Pod，那么接下来Pod的启动，更新，删除都是通过相关的Controller进行。首先Controller获取Etcd里面的Pod资源的状态，这个状态是Pod的期望状态（desired state）；并通过当前状态（current state）来决定下一步的操作。然后两个状态不一致，Controller需要更新Pod的当前状态，比如image不一致需要重建container。通过对比“期望状态”和“实际状态”的差异，完成了一次调协（Reconcile）的过程。</p>
<p>大家可以看到整个Kubernetes里面的所有组件，他们之间的协同都是通过来watch Etcd里面它所关心的Object的变化，然后再决定这个变化之后我要做什么。像这样的一种设计模式我们称之为Controller 范式。标准的“Kubernetes 编程范式”，即：</p>
<blockquote>
<p>如何使用控制器模式，同 Kubernetes 里 API 对象的“增、删、改、查”进行协作，进而完成用户业务逻辑的编写过程。</p>
</blockquote>
<h1 id=2-controller-pattern>2. Controller pattern</h1>
<p>Controller监控一组Kubernetes内的资源并且维护资源对象在集群中的状态，维护的方法是通过定期监听资源对象状态并协调（reconcile）资源对象的<strong>当前状态</strong>和声明的<strong>期望状态</strong>。Kubernetes Master的组件中包含一组controllers来管理Kubernetes原生的资源类型，比如节点，Replication，Endpoints等。这些controllers统一由kube-controller-manager组件来管理。</p>
<p>Kubernetes被设计成通过上述声明式API来管理资源。当我们谈论“声明式的”的时候谈论的是什么？与指令式方法相比，声明式方法不会指定Kubernetes怎么去完成部署任务，只是描述任务目标的状态应该是什么样子。例如，当我们水平扩展一个Deployment时，我们并不会通过向Kubernetes发出“创建一个新Pod”的请求来创建新的pods。而是通过修改Deployment中的replicas属性来声明资源的变化。</p>
<p>那么所需要的Pod是怎么被创建的呢？这就是我上面提到的Controller来完成。对于每一次状态的变化，Kubernetes都会创建一个包含这个对象变化的事件，并广播给所有监听这个资源的监听器（listeners）。这些监听器会创建其他的事件分发给其他的Controllers。监听这些事件的Controllers再进行下一步操作。比如Deployment controller在scale up的时候会更新它所控制的ReplicaSets的属性。</p>
<p><a href=https://github.com/kubernetes/kubernetes/blob/v1.13.6/pkg/controller/deployment/sync.go#L402-L421>https://github.com/kubernetes/kubernetes/blob/v1.13.6/pkg/controller/deployment/sync.go#L402-L421</a></p>
<pre><code>func (dc *DeploymentController) scaleReplicaSet(rs *apps.ReplicaSet, newScale int32, deployment *apps.Deployment, scalingOperation string) (bool, *apps.ReplicaSet, error) {

	sizeNeedsUpdate := *(rs.Spec.Replicas) != newScale

	annotationsNeedUpdate := deploymentutil.ReplicasAnnotationsNeedUpdate(rs, *(deployment.Spec.Replicas), *(deployment.Spec.Replicas)+deploymentutil.MaxSurge(*deployment))

	scaled := false
	var err error
	if sizeNeedsUpdate || annotationsNeedUpdate {
		rsCopy := rs.DeepCopy()
		*(rsCopy.Spec.Replicas) = newScale
		deploymentutil.SetReplicasAnnotations(rsCopy, *(deployment.Spec.Replicas), *(deployment.Spec.Replicas)+deploymentutil.MaxSurge(*deployment))
		rs, err = dc.client.AppsV1().ReplicaSets(rsCopy.Namespace).Update(rsCopy)
		if err == nil &amp;&amp; sizeNeedsUpdate {
			scaled = true
			dc.eventRecorder.Eventf(deployment, v1.EventTypeNormal, &quot;ScalingReplicaSet&quot;, &quot;Scaled %s replica set %s to %d&quot;, scalingOperation, rs.Name, newScale)
		}
	}
	return scaled, rs, err
}
</code></pre>
<p>值得注意的是，Controller监听的不是变化事件，而是资源对象的状态。监听者可以一次又一次地检查资源状态直到当前状态满足期望的条件。</p>
<p>这一组监听-更新的流程被称为状态协调（state reconciliation）：当期望状态和当前状态不同时，Controller的任务就是协调对象使其状态成为期望状态。从这个角度来讲，Kubernetes本质上就是分布式状态管理器。你提供给Kubernetes 应用实例的期望状态，Kubernetes会通过一系列调用来努力维护实例的状态。</p>
<p>当然，Kubernetes这种通用型的应用编排平台无法满足所有的应用编排需求。Kubernetes支持在原生的通过扩展的方法来实现满足开发者特殊需求的Controller。</p>
<p>在进行定制化前，我们需要经一步的理解状态协调的过程。我们已经知道上述Kubernetes内置的Controllers在Master节点上管理标准的Kubernetes资源。这些Controllers之间是相互不可知的，各自在一个无尽的协调循环中监控他们所感兴趣的资源状态，并更新资源实例使其状态成为目标状态。</p>
<p>定制化的Controller可以通过和这些原生的Controllers一样的方式，来添加复杂应用的编排逻辑。定制化的Controller遵循同样的逻辑来监听系统中的事件并完成指定的行为。状态协调包含如下3个步骤：</p>
<ul>
<li>观察：通过监控Kubernetes资源对象变化的事件来获取当前对象状态。</li>
<li>分析：确定当前状态和期望状态的不同</li>
<li>执行：执行能够驱动对象当前状态变化的操作</li>
</ul>
<p><img src=http://edwardsblog.edwardesire.com/image/2019/05/FllpeVuHJ8O2FieM3DCSP9skJg61.png alt="observe-analyze-act cycle"></p>
<p>例如，ReplicaSet controller会监控ReplicaSet对象的变化，并分析目标状态需要多少Pods运行，然后在向API Server请求创建缺少的Pods。Kubernetes的后端（准确的说是是Master上的kube-scheduler）负责在节点上启动新的Pod。</p>
<p>Controllers属于Kuberrnetes控制平面（control plane）的组件，成为了扩展平台管理复杂应用的标准机制。并且，一类名为Operator的框架基于Controller pattern实现了更加成熟的管理应用机制。从发展关系和复杂度来说，我们可以把这两类方法总结如下：</p>
<ul>
<li>
<p>Controllers：一种简单的状态协调流程，监控和管理Kubernetes标准的资源对象。经一步说，Controllers是扩展平台行为并赋予平台新的功能。</p>
</li>
<li>
<p>Operators：一种复杂的状态协调流程，通常会和CRD(我<a href=/2019/01/07/intro-operator/>上一篇文章</a>有介绍)结合使用。CRD是Operatorfang范式的核心。通常来说，Operators会封装复杂应用的编排逻辑，使得应用的编排管理自动化。</p>
</li>
</ul>
<p>最后，我找到一些值得学习的Controllers例子：</p>
<ul>
<li>
<p><a href=https://github.com/jenkins-x/exposecontroller>jenkins-x/exposecontroller</a>：这个Controller监控Kube Service的定义。当他发现对象的metadata.annotation有<code>exposed</code>的存在就会自动地为这个Service创建一个Ingress对象。</p>
</li>
<li>
<p><a href=https://github.com/fabric8io/configmapcontroller>fabric8/configmapcontroller</a>：
这个Controller监控ConfigMap对象。当ConfigMap有变化时，他会对依赖这个ConfigMap的Deployment进行滚动更新。</p>
</li>
<li>
<p><a href=https://github.com/fabric8io/configmapcontroller>Container Linux Update Operator</a>：这个Controller会检查节点是否有相应的annotation，并重启节点。</p>
</li>
</ul>
</div>
<div class=my-4>
<a href=/tags/kubernetes/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#Kubernetes</a>
<a href=/tags/operator/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#Operator</a>
</div>
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
<div>
<span class="block font-bold">Previous</span>
<a href=/posts/intro-of-cf-operator/ class=block>cf-operator的介绍</a>
</div>
<div class="md:text-right mt-4 md:mt-0">
<span class="block font-bold">Next</span>
<a href=/posts/intro-operator/ class=block>Intro Operator</a>
</div>
</div>
<div id=disqus_thread></div>
<script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//edwardesire.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<div class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded p-6">
<h2 class="text-lg font-semibold mb-4">See Also</h2>
<div class=content>
<a href=/posts/intro-operator/>Intro Operator</a>
<br>
<a href=/posts/deploy-kubernetes-by-kubeadm/>双机环境部署Kubernetes</a>
<br>
</div>
</div>
</div>
<script>document.addEventListener('DOMContentLoaded',()=>{hljs.initHighlightingOnLoad()})</script>
</div>
</div>
</main>
<footer class=pl-scrollbar>
<div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
<p class="text-sm text-tertiary-text">&copy; 2021 <a href=https://www.edwardesire.com/>Edward Desire</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p>
</div></div>
</footer>
</body>
</html>