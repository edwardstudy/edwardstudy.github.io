<!doctype html><html lang=en><meta charset=utf-8>
<meta name=viewport content="width=device-width">
<title>Node.js的事件驱动模型 | Edwardesire</title>
<meta name=generator content="Hugo Eureka 0.8.3">
<link rel=stylesheet href=/css/eureka.min.css>
<script defer src=/js/eureka.min.js></script>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link rel=preload href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap" as=style onload="this.onload=null,this.rel='stylesheet'">
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js integrity="sha256-uNYoXefWRqv+PsIF/OflNmwtKM4lStn9yrz2gVl6ymo=" crossorigin></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X media=print onload="this.media='all',this.onload=null" crossorigin>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script>
<script defer src=https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js integrity="sha256-Zmpaaj+GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE=" crossorigin></script>
<link rel=icon type=image/png sizes=32x32 href=/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_3.png>
<link rel=apple-touch-icon sizes=180x180 href=/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_3.png>
<meta name=description content="Node利用Javascript的特性，比如Continuation Passing Style(CPS)以及Event Loop，使得程序运行时表现优秀，CPS和Ev">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"/post/"},{"@type":"ListItem","position":2,"name":"Node.js的事件驱动模型","item":"/post/nodejs-event-model/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"/post/nodejs-event-model/"},"headline":"Node.js的事件驱动模型 | Edwardesire","datePublished":"2015-05-09T03:41:16+00:00","dateModified":"2015-05-09T03:41:16+00:00","wordCount":3341,"publisher":{"@type":"Person","name":"C. Wang","logo":{"@type":"ImageObject","url":"/images/icon.png"}},"description":"Node利用Javascript的特性，比如Continuation Passing Style(CPS)以及Event Loop，使得程序运行时表现优秀，CPS和Ev"}</script><meta property="og:title" content="Node.js的事件驱动模型 | Edwardesire">
<meta property="og:type" content="article">
<meta property="og:image" content="/images/icon.png">
<meta property="og:url" content="/post/nodejs-event-model/">
<meta property="og:description" content="Node利用Javascript的特性，比如Continuation Passing Style(CPS)以及Event Loop，使得程序运行时表现优秀，CPS和Ev">
<meta property="og:locale" content="en">
<meta property="og:site_name" content="Edwardesire">
<meta property="article:published_time" content="2015-05-09T03:41:16+00:00">
<meta property="article:modified_time" content="2015-05-09T03:41:16+00:00">
<meta property="article:section" content="post">
<meta property="article:tag" content="Nodejs">
<meta property="og:see_also" content="/post/tty-web-terminal/">
<meta property="og:see_also" content="/post/socketio-of-interest/">
<meta property="og:see_also" content="/post/mean-create-restful-web-service/">
<meta property="og:see_also" content="/post/run-mean-on-ec2/">
<meta property="og:see_also" content="/post/centos-install-nodejs/">
<meta property="og:see_also" content="/post/nodejs-serialize-dtree/">
<body class="flex flex-col min-h-screen">
<header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
<div class="w-full max-w-screen-xl mx-auto"><script>let storageColorScheme=localStorage.getItem("lightDarkMode");((storageColorScheme=='Auto'||storageColorScheme==null)&&window.matchMedia("(prefers-color-scheme: dark)").matches||storageColorScheme=="Dark")&&document.getElementsByTagName('html')[0].classList.add('dark')</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
<a href=/ class="mr-6 text-primary-text text-xl font-bold">Edwardesire</a>
<button id=navbar-btn class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
<i class="fas fa-bars"></i>
</button>
<div id=target class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
<div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
<a href=/post/ class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2 selected-menu-item mr-4">Posts</a>
</div>
<div class=flex>
<div class="relative pt-4 md:pt-0">
<div class="cursor-pointer hover:text-eureka" id=lightDarkMode>
<i class="fas fa-adjust"></i>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id=is-open>
</div>
<div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40" id=lightDarkOptions>
<span class="px-4 py-1 hover:text-eureka" name=Light>Light</span>
<span class="px-4 py-1 hover:text-eureka" name=Dark>Dark</span>
<span class="px-4 py-1 hover:text-eureka" name=Auto>Auto</span>
</div>
</div>
</div>
</div>
<div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id=is-open-mobile>
</div>
</nav>
<script>let element=document.getElementById('lightDarkMode');storageColorScheme==null||storageColorScheme=='Auto'?document.addEventListener('DOMContentLoaded',()=>{window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change',switchDarkMode)}):storageColorScheme=="Light"?(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'sun'),element.firstElementChild.classList.add('fa-sun')):storageColorScheme=="Dark"&&(element.firstElementChild.classList.remove('fa-adjust'),element.firstElementChild.setAttribute("data-icon",'moon'),element.firstElementChild.classList.add('fa-moon')),document.addEventListener('DOMContentLoaded',()=>{getcolorscheme(),switchBurger()})</script>
</div>
</header>
<main class="flex-grow pt-16">
<div class=pl-scrollbar>
<div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">
<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
<div class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
<h1 class="font-bold text-3xl text-primary-text">Node.js的事件驱动模型</h1>
<div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
<div class="mr-6 my-2">
<i class="fas fa-calendar mr-1"></i>
<span>2015-05-09</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-clock mr-1"></i>
<span>7 min read</span>
</div>
<div class="mr-6 my-2">
<i class="fas fa-folder mr-1"></i>
<a href=/categories/nodejs/ class=hover:text-eureka>Nodejs</a>
</div>
</div>
<div class=content>
<p>Node利用Javascript的特性，比如Continuation Passing Style(CPS)以及Event Loop，使得程序运行时表现优秀，CPS和Event Loop一套机制是用libuv库(libuv又根据OS的不同抽象了Unix下libev和Windos下ICOP)提供的。JS中处理IO业务的方法将回调函数当参数传递的编程风格就是CPS。而成为参数的回调函数的调用问题就得需要叫事件循环来控制。这一切就实现了Node的异步IO。</p>
<hr>
<ol>
<li>经典的服务器执行模型</li>
</ol>
<p>经典的服务器执行模型有同步式、进程式、线程式。</p>
<p>同步式模型就是每次值处理一个请求，迭代地将所有请求处理完毕。无并发可言，处理效率当然很低。</p>
<p>进程式模型为每一个Web请求开启一个进程，这样可以同时处理多个请求，但式当请求量太大时有限的系统资源就比较吃紧了。并且为每个请求现场分配一个子进程比较消耗cpu时间。</p>
<p>线程式模型为每一个ieWeb请求开启一个线程处理。线程式又包括单线程模型、多线程模型，也就是一个进程中几个个线程，像Apache就可以选择Worker MPM(多进程多线程)还是Prefork MPM(多进程单线程)。多线程模型处理并发的方式是将每一个IO操作分配到单独的线程中。当客户端发出请求给服务器，服务器会对请求处理并准备好响应回传给客户端，服务器通过维持一个有限的线程池来执行能分离开的处理任务。</p>
<p><img src=http://edwardsblog.qiniudn.com/image/a/7d/92b8c17b1a1131b98aae301eac61b.png alt></p>
<p>每一个线程分担一个任务听起来很不错，但这会冒出两个问题：其一，线程的数量是有限制的，当你的任务量大于可调度的线程时，就会发生等待处理资源的情况；其二，线程上的任务是共用资源，当线程面对堵塞IO的事务很长时间时，通过线程锁来阻止资源的使用。对于数据密集性的应用来说，这两个问题可能会导致低效的Web服务。建立一个单独的线程需要一些资源配置(runtime、heap、memory)以及处理线程之间的上下文。像图中这种web请求可能还好，文件请求和数据库请求基还是正交的，可以单独处理执行；但这还是避免不了在等待数据结果时当前线程的空闲等待，异步处理就能提高程序运行的效率。</p>
<ol start=2>
<li>事件驱动</li>
</ol>
<p>与Nginx的服务原理类似，Node采用事件驱动的运行方式。不过nginx式多进程单线程，而Node通过事件驱动的方式处理请求时无需为每一个请求创建额外的线程。在事件驱动的模型当中，每一个IO工作被添加到事件队列中，线程循环地处理队列上的工作任务，当执行过程中遇到来堵塞(读取文件、查询数据库)时，线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。这个传递到队列中的回调函数在堵塞任务运行结束后才被线程调用。</p>
<p><img src=http://edwardsblog.qiniudn.com/image/5/51/c00ec61c78177ea9aa0e2e698bd0c.png alt></p>
<p>前面也说过Node Async IO = CPS + Callback，这一套实现开始于Node开始启动的进程，在这个进程中Node会创建一个循环，每次循环运行就是一个Tick周期，每个Tick周期中会从事件队列查看是否有事件需要处理，如果有就取出事件并执行相关的回调函数。事件队列事件全部执行完毕，node应用就会终止。Node对于堵塞IO的处理在幕后使用线程池来确保工作的执行。Node从池中取得一个线程来执行复杂任务，而不占用主循环线程。这样就防止堵塞IO占用空闲资源。当堵塞任务执行完毕通过添加到事件队列中的回调函数来处理接下来的工作。</p>
<p><img src=http://edwardsblog.qiniudn.com/image/b/08/20667b5e8f16f2aeb543d206c1614.png alt></p>
<p>当然这么华丽的运行机制就能解决前面说的两个弊端。node基于事件的工作调度能很自然地将主要的调度工作限制到了一个线程，应用能很高效地处理多任务。程序每一时刻也只需管理一个工作中的任务。当必须处理堵塞IO时，通过将这个部分的IO控制权交给池中的线程，能最小地影响到应用处理事件，快速地反应web请求。
当然对机器方便的事情对于写代码的人来说就需要更小心地划分业务逻辑，我们需要将工作划分为合理大小的任务来适配事件模型这一套机制。</p>
<ol start=3>
<li>事件队列调度</li>
</ol>
<p>Node可以通过传递回调函数将任务添加到事件队列中，这种异步的调度可以通过5种方式来实现这个目标：异步堵塞IO库(db处理、fs处理)，Node内置的事件和事件监听器(http、server的一些预定义事件)，开发者自定义的事件和监听器、定时器以及Node全局对象process的.nextTick()API。</p>
<p>3.1 异步堵塞IO库</p>
<p>其IO库提供的API有Node自带的Module(比如fs)和数据库驱动API，比如mongoose的.save(doc, callback)就是将繁重的数据库Insert操作以及回调函数交给子线程来操作，主线程只负责任务的调度。当MongoDB返回给Node操作结果后，回调函数才开始执行。</p>
<pre><code>    Dtree.create(frontData, function (err, dtree) {
          if (err) {
                console.log('Error: createDTree: DB failed to create due to ', err);
                res.send({'success': false, 'err': err});
          } else {
                console.log('Info: createDTree: DB created successfully dtree = ', dtree);
                res.send({'success': true, 'created_id': dtree._id.toHexString()});
          }
    });
</code></pre>
<p>比如这段处理Dtree存储的回调函数只有当事件队列中的接收到来自堵塞IO处理线程的执行完毕才会被执行。</p>
<p>3.2 Node内置的事件和事件监听器</p>
<p>Node原生的模块都预定义来一些事件，比如NET模块的一套服务状态事件。当Net中的Socket检测到close就会调用放置在事件循环中的回调函数，下例中就是将sockets数组中删除相应的socket连接对象。</p>
<pre><code>    socket.on('close', function(){
      console.log('connection closed');
      var index = sockets.indexOf(socket);
      //服务器端断开相应连接
      sockets.splice(index, 1);
    });
</code></pre>
<p>3.3 开发者自定义的事件</p>
<pre><code>Node自身和很多模块都支持开发者自定义事件和处理持戟处理函数，当然既然是自定义，那么触发事件也是显性地需要开发者。在Socket.io编程中就有很好的例子，开发者可以自定义消息事件来处理端对端的交互。

    //socket监听自定义的事件消息
    socket.on('chatMessage', function(message){
      message.type = 'message';
      message.created = Date.now();
      message.username = socket.request.user.username;
      console.log(message);
      //同时也可以像对方发出事件消息
      io.emit('chatMessage', message);
    });
</code></pre>
<p>3.4 计时器(Timers)</p>
<p>Node使用前端一致的Timeout和Interval计时器，他们的区别在Timeout是延时执行，Interval是间隔一段事件执行。值得注意的是这组函数其实不属于JS语言标准，他们只是扩展。在浏览器中，他们属于BOM，即它的确切定义为：window.setTimeout和window.setInterval；与window.alert, window.open等函数处于同一层次。Node把这组函数放置于全局范围中。</p>
<p>除了这两个函数，Node还添加Immediate计时器，setImmediate()函数是没有事件参数的，在事件队列中的当前任务执行结束后执行，并且优先级比Timeout、Interbal高。</p>
<p>计时器的问题在于它在事件循环中并非精确的执行回调函数。《深入浅出Node.js》举了一个例子：当通过setTimeout()设定一个任务在10毫秒后执行，但是如果在9毫秒后，有一个任务占用了5毫秒的CPU，再次炖老定时器执行时，事件就已经过期了。</p>
<p>3.5 Node全局对象process的.nextTick()API</p>
<p>这个延时执行函数函数是在添加任务到队列的开头，下一次Tick周期开始时就执行，也就是在其他任务前调度。</p>
<p>nextTick的优先级是高于immediate的。并且每轮循环，nextTick中的回调函数全部都会执行完，而Immediate只会执行一个回调函数。这里有得说明每个Tick过程中，判断事件循环中是否有事件要处理的观察者。在Node的底层libuv，事件循环是一个典型的生产者/消费者模型。异步IO、网络请求是事件的生产者，回调函数是事件的消费者，而观察者则是在中间将传递过来的事件暂存起来。回调函数的idle观察者在每轮事件循环开始被检查，而check观察者后于idle观察者检查，两者之间被检查的就是IO操作的观察者。</p>
<ol start=4>
<li>事件驱动与高性能服务器</li>
</ol>
<p>前面大致介绍了Node的事件驱动模型，事件驱动的实质就是主循环线程+事件触发的方式来运行程序。Node的异步IO成功地使得IO操作与CPU操作分离成为一套高性能平台，既可以像Nginx一样构建服务器平台，也可以处理具体的业务。虽然Node没有Nginx在Web服务器方面那么专业，但不错的性能和更多的使用场景使得在实际开发中能够达到优异的性能。这一切也都归功与异步IO实现的核心——事件循环。在实际的项目中，我们可以结合不同工具的优点达到应用的最优性能。</p>
<hr>
<p>references:</p>
<ol>
<li><a href=http://stackoverflow.com/a/14797359>Answer of Async</a></li>
<li><a href=http://blog.csdn.net/cnnzp/article/details/7832106>Continuation-passing Style</a></li>
<li><a href=https://cnodejs.org/topic/4f16442ccae1f4aa2700109b>关于Timeout计时器的文章</a></li>
<li><a href=http://nikhilm.github.io/uvbook/index.html>An Introduction to libuv</a></li>
<li><a href=http://becausejavascript.com/node-js-process-nexttick-vs-setimmediate/>process.nextTick() vs. setImmediate()</a></li>
<li><a href=http://book.douban.com/subject/25768396/>Book: 深入浅出Node.js</a></li>
<li><a href=http://book.douban.com/subject/25924232/>Book: Node.js, MongoDB, and AngularJS Web Development</a></li>
</ol>
</div>
<div class=my-4>
<a href=/tags/nodejs/ class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#Nodejs</a>
</div>
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
<div>
<span class="block font-bold">Previous</span>
<a href=/post/the-mongodb-tempter/ class=block>MongoDB理论浅入浅出</a>
</div>
<div class="md:text-right mt-4 md:mt-0">
<span class="block font-bold">Next</span>
<a href=/post/kick-ass-update-ghost/ class=block>闲着蛋疼：将Ghost升级到0.6.2</a>
</div>
</div>
<div id=disqus_thread></div>
<script>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//edwardesire.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<div class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded p-6">
<h2 class="text-lg font-semibold mb-4">See Also</h2>
<div class=content>
<a href=/post/tty-web-terminal/>tty.js:实现Web Terminal</a>
<br>
<a href=/post/socketio-of-interest/>Socket.io:有点意思</a>
<br>
<a href=/post/mean-create-restful-web-service/>MEAN Stack:创建RESTful web service</a>
<br>
<a href=/post/run-mean-on-ec2/>在EC2上安装MEAN环境</a>
<br>
<a href=/post/centos-install-nodejs/>CentOS 6.3安装NodeJS环境</a>
<br>
<a href=/post/nodejs-serialize-dtree/>NodeJS:树的序列化</a>
<br>
</div>
</div>
</div>
<script>document.addEventListener('DOMContentLoaded',()=>{hljs.initHighlightingOnLoad()})</script>
</div>
</div>
</main>
<footer class=pl-scrollbar>
<div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
<p class="text-sm text-tertiary-text">&copy; 2021 <a href=https://www.edwardesire.com/>Edward Desire</a>
&#183; Powered by the <a href=https://github.com/wangchucheng/hugo-eureka class=hover:text-eureka>Eureka</a> theme for <a href=https://gohugo.io class=hover:text-eureka>Hugo</a></p>
</div></div>
</footer>
</body>
</html>